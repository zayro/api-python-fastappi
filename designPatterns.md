# Patrones de Diseños

Los patrones de diseño son soluciones generales a problemas comunes en el desarrollo de software. Estos patrones son una descripción de una solución a un problema que puede ser aplicado en diferentes situaciones.

ejemplos de patrones de diseño son: `Singleton`, `Factory`, `Builder`, `Adapter`, `Decorator`, `Strategy`, `Observer`, `Command`, `State`, `Template Method`, `Composite`, `Proxy`, `Chain of Responsibility`, `Flyweight`, `Facade`, `Mediator`, `Memento`, `Visitor`, `Interpreter`, `Iterator`, `Prototype`.

## Tipos de patrones de diseño

Los patrones de diseño se pueden clasificar en tres categorías:

1. **Creacionales**: Estos patrones de diseño se centran en la creación de objetos. Estos patrones proporcionan una forma de crear objetos sin tener que especificar la clase exacta de objeto que se creará. Los patrones creacionales más comunes son: `Singleton`, `Factory`, `Builder`, `Prototype`, `Abstract Factory`.

2. **Estructurales**: Estos patrones de diseño se centran en la composición de clases y objetos. Estos patrones describen cómo las clases y objetos se pueden combinar para formar estructuras más grandes. Los patrones estructurales más comunes son: `Adapter`, `Decorator`, `Facade`, `Proxy`, `Bridge`, `Composite`, `Flyweight`.

3. **Comportamiento**: Estos patrones de diseño se centran en la comunicación entre objetos. Estos patrones describen cómo los objetos interactúan entre sí para realizar una tarea. Los patrones de comportamiento más comunes son: `Observer`, `Strategy`, `Command`, `State`, `Template Method`, `Chain of Responsibility`, `Interpreter`, `Iterator`, `Mediator`, `Memento`, `Visitor`.

## Principios de diseño

Los patrones de diseño se basan en los siguientes principios de diseño:

1. **Abierto/Cerrado**: Los objetos deben estar abiertos para la extensión pero cerrados para la modificación. Esto significa que los objetos deben poder ser extendidos para agregar nuevas funcionalidades sin tener que modificar el código existente.

2. **Sustitución de Liskov**: Los objetos de una clase base deben poder ser reemplazados por objetos de una clase derivada sin afectar el comportamiento del programa. Esto significa que las clases derivadas deben poder ser usadas en lugar de las clases base sin cambiar el comportamiento del programa.

3. **Segregación de la interfaz**: Los clientes no deben verse obligados a depender de interfaces que no utilizan. Esto significa que las interfaces deben ser lo más pequeñas y específicas posible para que los clientes solo tengan que depender de las interfaces que necesitan.

4. **Inversión de dependencias**: Las clases de alto nivel no deben depender de las clases de bajo nivel. En su lugar, ambas clases deben depender de abstracciones. Esto significa que las clases de alto nivel deben depender de interfaces en lugar de clases concretas.

## Bibliografia

- [Design Patterns: Elements of Reusable Object-Oriented Software](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612) by Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides

- <https://refactoring.guru/es/design-patterns/catalog>

- <https://cynoteck.com/es/blog-post/top-software-development-models-to-choose-from/>
